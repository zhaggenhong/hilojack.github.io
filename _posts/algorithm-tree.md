---
layout: page
title:	数据结构之树
category: blog
description: 
---
# Preface

树状图是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

1. 每个节点有零个或多个子节点；
1. 没有父节点的节点称为根节点；
1. 每一个非根节点有且只有一个父节点；
1. 除了根节点外，每个子节点可以分为多个不相交的子树；

# 术语
- 节点的度：一个节点含有的子树的个数称为该节点的度；二叉树的度小于等于2
- 树的度：一棵树中，最大的节点的度称为树的度；
- 叶节点或终端节点：度为零的节点；
- 非终端节点或分支节点：度不为零的节点；
- 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
- 兄弟节点：具有相同父节点的节点互称为兄弟节点；
- *节点的层次*：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
- *树的高度或深度*：树中节点的最大层次；
- 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
- 节点的祖先：从根到该节点所经分支上的所有节点；
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
- 森林：由m（m>=0）棵*互不相交的树*的集合称为森林

# 存储
一般树使用多用nodes 数组存储, node 之间关系通过链表实现

# 分类
无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；	
有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；	
	二叉树：每个节点最多含有两个子树的树称为二叉树；	
		完全二叉树：对于一颗二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；	
		满二叉树：对于上述的完全二叉树，如果去掉其第d层的所有节点，那么剩下的部分就构成一个满二叉树（此时该满二叉树的深度为d-1）；	
	霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；	
	B树	

## Binary Tree 二叉树
最多含两个结点的树(树的度不大于2), 通常被用于实现二叉查找树和二叉堆。

* 完全二叉树和满二叉树
- 满二叉树（Full Binary Tree）：一棵深度为k，且有2^k-1个节点称之为满二叉树
- 完全二叉树（Complete Binary Tree）：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树
- 二叉查找树([Binary Search Tree](/p/algorithm-binary-search-tree))

### 特性
|完全二叉树	|满二叉树|
|总节点k	|2^{h-1}<= k <= 2^h-1	|k = 2^h-1|
|树高h	|h = log_2k+1	|h = log_2(k+1) |

> 二叉树在图论中是这样定义的：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林

### 存储

#### 顺序存储
只适合完全二叉树(包括满二叉)，否则非常浪费空间

#### 二叉链表存储
适合存储所有的二叉树，查找父结点需要遍历整个链表

#### 三叉链表存储
改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。

* 线索二叉树 (threaded binary tree)
在后序线索树中找到结点的后继分三种情况：

- 若结点是二叉树的根，则其后继为空；
- 若结点是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；
- 若结点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树上按后序遍历列出的第一个结点。

### 遍历二叉树

#### 深度优先遍历（Deep First Search）
DFS是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
和图的深度优先搜索不同的是，不需记住访问过的每一个结点，因为树中不会有环。
前序（Pre-order Traversal）、中序（In-order Traversal）、后序遍历（Post-order Traversal）都是深度优先遍历的特例。

- 前序: 根左右
- 中序: 左根右
- 后序: 左右根

* 复杂度
DFS 搜索时间复杂度是`O(b^m)`, 空间复杂度是`O(b*m)`, 其中b 是最大分支系数，m 是图的最大深度. 
对于二叉树来说，b = 2, 2^m 与结点数是同一数量级O(n);
而b*m 其实是栈所消耗的空间: 每增加一层深度，就要在栈中添加b-1 个结点，之所以减1 是因为有一个结点要被弹出并继续深度搜索下去。所以总的空间为O((b-1)*m) = O(b*m). 对于二叉树来说，就是`O(m)`.

* 算法
1. 算法借助递归实现, 使用与树的高度成比例的栈空间:
2. 算法借助栈(先入后出)实现。

中序递归算法:

	//中序: 左根右
	visit(node)
		if node.left  != null then visit(node.left)
		print node.value
		if node.right != null then visit(node.right)

如果我们在每个结点中存储指向父结点的指针，那样可以使用迭代算法，只使用常数空间实现所有这些遍历。然而，指向父结点的指针占用更多的空间。这只在需要指向父节点的指针或栈空间有限时才使用。

中序遍历的迭代算法:

	visit(node)
		while(node != NULL){
			//parent
			if(node.right && prev in node.right){
				prev = node;
				node = node.parent;
			}elseif(!node.right && (!node.left || prev in node.left ) ){
				print node;
				prev = node;
				node = node.parent;
			//right
			}elseif(
				(!node.left || prev in node.left  )
				&& node.right && !prev in node.right){
				print node;
				prev = node;
				node = node.right;
			//left
			}else(node.left && !prev in node.left){
				prev = node;
				node = node.left;
			}
		}
		

#### 广度优先遍历 (Bread First Search)
- 层级遍历
和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。参见广度优先搜索。 二叉树的广度优先遍历又称按层次遍历。

* 复杂度
BFS 搜索时因为要遍历所有的点(V)+路径(E), 所以其时间复杂度和空间复杂度都为`O(|V|+|E|)`
* 算法
算法借助队列实现。


### 将n叉树转换为二叉树
![n-tree](/img/n-tree.png)
将一棵树转换为二叉树的方法：
1. 在兄弟之间加一连接；
2. 对每个结点，除了其左孩子外，去除其与其余孩子之间的联系；
3. 以树的根结点为轴心，将整树顺时针转45度。

这样的话，右树

# Reference
- [树]

[树]: http://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
