---
layout: page
title:	单链表是否有环之龟兔算法(tortoise-hare)
category: blog
description: 
---
# Preface
![cycle](/img/cycle-detection.png)
![c](http://farm4.staticflickr.com/3843/14971507581_30932e722a_o.jpg)

检测单链表上的环分为三个问题：
1. 单链表上是否有环
2. 环的长度是多少
3. 环的起点在哪里？

通常我们所想到的方法是，遍历 并通过hash 表判断是否能回到起点. 这种算法的空间消耗比较大。还有一种龟兔算法(tortoise-hare), 能在消耗空间的情况下解决这一问题。

# 基本思想

## 是否有环，及环的长度
如果链表存在环，那么 龟 和 兔 从链表起点出发，每次龟走一步，走两步(step=2)，那么经过m+k 次后，龟兔必定相遇。此时，

- 龟走了: s(tortoise) = m+k
- 兔走了: s(hare) = 2(m+k)

如果他们能相遇，我们就能确定链表有环，且环的长度为`n = s(sortoise)`

## 环的起点
还剩下一个问题是：环的起点在哪里？再分析一下当龟兔相遇时，大家再走m 步就到起点了，可是m 是未知的呢。其实不用理会m，让龟回到起点，然后大家同时走，每次都走一步。经过m 步后，大家一定能在环的起点相遇。

## 反思一下，兔子每次走3步可以吗？
假设兔子每次走step 步，那么只要满足

((step -1) * (m + k)) / n === N  

(其中N 为正整数, step 为大于1的整数) , 就能使二者相遇(k 为最小非负整数)。那么环的长度为：

n = ((step -1) * (m + k)) / N

但是N 是不确定的，比如 step=4, n = 4, m = 1, 那么 n = (3*(1+k))/4 有k=3 使得二者相遇， n = 3*(1+3)/N 中，N=3, N = 1 使得n=12,4都能满足要求。

所以，step 只能取2，才能使 step-1 与任何 n 的遇大公约数为1. N 只能为1
