---
layout: page
title:	linux nginx development
category: blog
description: 
---
# Preface

# Todo
http://www.360doc.cn/article/12523329_379501516.html

http://tengine.taobao.org/book/index.html

# epoll 非阻塞
最初的服务器是基于进程(线程)的, 对于并发C10K 的网站，每个请求都开一个进程/线程，服务器将不堪负重(进程是OS最昂贵的资源)。

这个时候，就需要用于非阻塞模式(一个线程进程，不再一个请求处理完再处理下一个请求). 于是FreeBSD推出了kqueue，linux 推出了epoll.

epoll技术的编程模型就是非阻塞回调，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）。Epoll就是为了解决C10K问题而生。使用Epoll技术，使得小公司也可以玩高并发。不需要购买很多服务器，有几台服务器就可以服务大量用户。Nginx，libevent，node.js这些就是Epoll时代的产物。


> 其它非阻塞模式，如：select/poll模型，这些技术都有一定的缺点，如selelct最大不能超过1024，poll没有限制，但每次收到数据需要遍历每一个连接查看哪个连接有数据请求。


Refer to：韩天峰 epoll
http://rango.swoole.com/archives/381

> 网络通信中叫非阻塞，很多人叫异步

## coroutine, 协程
epoll 采用的是异步非阻塞回调, 嵌套回调极难维护。

协程（coroutine）就应运而生。这个技术本质上也是非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。比如调用 client->recv() 等待接收数据时，就像阻塞代码一样写。实际上是底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。

> 这个就像时间禁止的游戏一样，国王对巫师说“我必须马上得到宝物，不然就砍了你的脑袋”，巫师念了一句时间停止的咒语，直到过了1年后勇士们才把宝物送来。这时候巫师解开咒语，把宝物交给国王。这里国王就可以理解成协程，他根本没感觉到时间停止，在他停止到醒来期间发生了什么他不知道，也不关心。

> 这就是协程的本质。协程是非阻塞的另外一种展现形式。Golang，Erlang，Lua协程都是这个模型。

### 同步阻塞
协程本质是非阻塞，但是表现起来和阻塞是一样的。所以协程也叫做用户态进/用户态线程。区别就在于进程/线程是操作系统充当了EventLoop调度，而协程是自己用Epoll进行调度。

协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行

> Erlang解决了协程密集计算的问题，它基于自行开发VM，并不执行机器码。即使存在密集计算的场景，VM发现某个协程执行时间过长，也可以进行中止切换。Golang由于是直接执行机器码的，所以无法解决此问题。所以Golang要求用户必须在密集计算的代码中，自行Yield。

实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，因为进程多了互相切换有开销。所以如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的。

### 异步非阻塞与协程
异步回调是没有切换开销的，它等同于顺序执行代码。所以异步回调程序的性能是要优于协程模型的。
协程虽然是用户态调度，实际上还是需要调度的(将异步回调做了封装)，既然调度就会存在上下文切换。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。
